

<!DOCTYPE html>
<html class="writer-html5" lang="en,pt-BR" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Registradores &mdash; CoopRobo 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Comunicação Serial" href="3.4-Serial.html" />
    <link rel="prev" title="Compilação Cruzada" href="3.2-CrossCompilation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> CoopRobo
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Robots</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../aerial.html">Aerial Robots</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../vr01.html">VR-01</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../1-autopilot/1.0-pilot.html">Piloto Automatico</a></li>
<li class="toctree-l3"><a class="reference internal" href="../1-autopilot/1.1-config_pilot.html">Configuração do Piloto Automatico</a></li>
<li class="toctree-l3"><a class="reference internal" href="../2-embedded_system/2.0-embedded_system.html">Sistema Embarcado</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="3.0-intro.html">Utilizando o computador embarcado</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="3.1-Ambient_Linux.html">Ambientando-se ao Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="3.2-CrossCompilation.html">Compilação Cruzada</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Registradores</a></li>
<li class="toctree-l4"><a class="reference internal" href="3.4-Serial.html">Comunicação Serial</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../vr01.html#referencias">Referências</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../mobile.html">Mobile Robots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../manipulators.html">Manipulators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs-ref.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../camera.html">Camera</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CoopRobo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../aerial.html">Aerial Robots</a> &raquo;</li>
        
          <li><a href="../../vr01.html">VR-01</a> &raquo;</li>
        
          <li><a href="3.0-intro.html">Utilizando o computador embarcado</a> &raquo;</li>
        
      <li>Registradores</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/aerial/vr01/3-gumstix/3.3-register.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="registradores">
<h1>Registradores<a class="headerlink" href="#registradores" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Este tópico precisa ser testado e reeditado.</p>
</div>
<p>Seguindo os procedimentos das seções anteriores somos capazes de iniciar o sistema e gerar programas a serem executados pelo sistema operacional. O próximo passo é, portanto, controlar os sinais que podem ser enviados a outros dispositivos pelo computador embarcado para estabelecer a comunicação entre os dispositivos.</p>
<p>A comunicação entre dispositivos é feita pela alteração dos níveis de tensão dos pinos do computador embarcado. Esses pinos estão, de uma maneira resumida, conectados a <strong>espaços de memória do sistema</strong> e quando alteramos o bit armazenado neste espaço de memória alteramos também o nível de tensão do pino, permitindo a codificação de uma mensagem e sua transmissão a outro dispositivo.</p>
<p>Posteriormente, a comunicação entre dispositivos será mais bem discutida, mas neste momento o que mais nos importa são os &quot;<strong>espaços de memória</strong>&quot; citados no parágrafo anterior. Esses espaços de memória são na verdade circuitos digitais voláteis que são capazes de armazenar níveis de tensão, o acesso ao conteúdo desses espaços de memória é extremamente rápido e a estes espaços de memória é dado o nome de <strong>registrador</strong>. Os registradores estão no topo da hierarquia de memória, sendo assim o tipo de memória mais rápida de uma unidade central de processamento.</p>
<p>Dessa forma, para que possamos implementar a comunicação entre dois dispositivos, um modem e o computador embarcado por exemplo, precisamos, primeiro, executar uma tarefa mais simples de alterar os níveis de tensão de um pino. Esse processo de alterar os níveis de tensão de um pino possui diversas aplicações que vão desde o simples controle de <strong>ON/OFF</strong> de um LED até comunicação serial entre dispositivos. Aos pinos com esse propósito é dado o nome de <a class="reference external" href="https://en.wikipedia.org/wiki/General-purpose_input/output">General Purpose Input/Output</a> (<strong>GPIO</strong>).</p>
<p><em>General Purpose Input/Output</em> (<strong>GPIO</strong>) são, basicamente, pinos de  comunicação de entrada e saída de sinais digitais, de um circuito integrado ou placa de circuito eletrônico, sem finalidade pré-definida, podendo assim ter funções definidas pelo projetista ou usuário para prover uma interface entre outros dispositivos (periféricos, modens, microcontroladores, microprocessadores etc.).</p>
<p>Como comentado anteriormente, estamos utilizando o computador embarcado Overo junto a uma placa de expansão Tobi. Uma das funções desta placa é fornecer acesso ao usuário aos pinos do computador embarcado, portanto os pinos do computador embarcado que podemos acessar fisicamente são os pinos da placa de expansão Tobi. Na figura abaixo podemos visualizar um diagrama que contém, de maneira resumida, quais funções ou pinos do computador embarcado estão conectadas a cada pino da placa de expansão Tobi. Observe que alguns desses pinos possuem mais de uma função.</p>
<div class="figure align-center" id="id1">
<img alt="../../../_images/Pinos_Tobi.png" src="../../../_images/Pinos_Tobi.png" />
<p class="caption"><span class="caption-text">Diagrama dos pinos da placa de expansão Tobi.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="controle-do-gpio-via-terminal">
<h2>Controle do GPIO via terminal<a class="headerlink" href="#controle-do-gpio-via-terminal" title="Permalink to this headline">¶</a></h2>
<p>A maneira mais simples, porém menos eficiente de se controlar o GPIO está descrita no próprio site da fabricante, disponível em <a class="reference external" href="https://www.gumstix.com/support/faq/overo-gpio/#cross-compilation">Control Overo GPIO</a> . Lá eles indicam controlar o GPIO pelo próprio terminal do sistema Linux através de um sistema <em>sysfs</em>. O sistema <em>sysfs</em> é um sistema de “arquivos“ oferecidos pelo núcleo do Linux para o controle e comunicação com dispositivos e drivers através do terminal do Linux.</p>
<p>Se, por exemplo, desejarmos controlar a saída do <strong>GPIO10</strong> através deste método para piscar um LED precisaremos exportar o <strong>GPIO10</strong> para o espaço do usuário escrevendo <code class="docutils literal notranslate"><span class="pre">10</span></code> no arquivo <em>/sys/class/gpio/export</em>, o que irá gerar um diretório com outros arquivos para a manipulação do <strong>GPIO10</strong>. Em seguida, devemos definir sua direção como de saída escrevendo <code class="docutils literal notranslate"><span class="pre">out</span></code> em <em>/sys/class/gpio/gpio10/direction</em> e definir seu valor como alto ou baixo escrevendo <code class="docutils literal notranslate"><span class="pre">1</span></code> ou <code class="docutils literal notranslate"><span class="pre">0</span></code> em <em>/sys/class/gpio/gpio10/value</em>.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>A função de configuração de interrupção também é acessível pelo terminal.</p>
</div>
<p>Este processo pode ser feito tanto pelo terminal do usuário com o comando <code class="docutils literal notranslate"><span class="pre">echo</span></code>, quanto por um programa que abra esse arquivo e escreve nela por nós. Por exemplo, para controlar o <strong>GPIO146</strong> através do terminal podemos executar os seguintes comandos (exemplo utilizado no site da Gumstix):</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lembrando que o comando <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">teste</span> <span class="pre">&gt;</span> <span class="pre">pasta/arquivo</span></code> irá sobrescrever todo o arquivo pela palavra &quot;teste&quot; e o comando <code class="docutils literal notranslate"><span class="pre">cat</span> <span class="pre">pasta/arquivo</span></code> irá exibir o conteúdo do arquivo.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span><span class="nd">@overo</span><span class="c1"># echo 146 &gt; /sys/class/gpio/export</span>
<span class="n">root</span><span class="nd">@overo</span><span class="p">:</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">class</span><span class="o">/</span><span class="n">gpio</span><span class="c1"># cat gpio146/direction</span>
<span class="ow">in</span>
<span class="n">root</span><span class="nd">@overo</span><span class="c1"># echo out &gt; /sys/class/gpio/gpio146/direction</span>
<span class="n">root</span><span class="nd">@overo</span><span class="p">:</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">class</span><span class="o">/</span><span class="n">gpio</span><span class="c1"># cat gpio146/direction</span>
<span class="n">out</span>
<span class="n">root</span><span class="nd">@overo</span><span class="c1"># cat /sys/class/gpio/gpio146/value</span>
<span class="mi">0</span>
<span class="n">root</span><span class="nd">@overo</span><span class="c1"># echo 1 &gt; /sys/class/gpio/gpio146/value</span>
<span class="n">root</span><span class="nd">@overo</span><span class="c1"># cat /sys/class/gpio/gpio146/value</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Esse comando controlará o pino 27 da placa Tobi.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Se você não possuir um medidor, um LED de 1,8V pode ser utilizado. Use o pino 1 como aterramento.</p>
</div>
<p>Porém, como já comentado, esse método é bem lento e não pode ser utilizado para comunicação entre dispositivos. Entretanto para atividades com períodos superiores a 100 milissegundos este método pode ser utilizado tranquilamente.</p>
<p>Outra abordagem, utilizando o mesmo método, é utilizar um código semelhante ao código apresentado abaixo, que escreve diretamente nos arquivos do <strong>GPIO</strong>. Essa abordagem foi testada e melhorou consideravelmente, através de um simples código, o tempo de resposta do GPIO.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &lt;string.h&gt;</span>
<span class="c1">#include &lt;stdlib.h&gt;</span>
<span class="c1">#include &lt;unistd.h&gt;</span>
<span class="c1">#include &lt;fcntl.h&gt;</span>
<span class="c1">#include &lt;termios.h&gt;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">int</span> <span class="n">arq</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/sys/class/gpio/export&quot;</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="n">arq</span><span class="p">,</span> <span class="s2">&quot;10&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">arq</span><span class="p">);</span>

    <span class="n">arq</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/sys/class/gpio/gpio10/direction&quot;</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
    <span class="n">write</span><span class="p">(</span><span class="n">arq</span><span class="p">,</span> <span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">arq</span><span class="p">);</span>

    <span class="n">arq</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/sys/class/gpio/gpio10/value&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">write</span><span class="p">(</span><span class="n">arq</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="o">//</span><span class="n">usleep</span> <span class="p">(</span><span class="mi">500000</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">arq</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="o">//</span><span class="n">usleep</span> <span class="p">(</span><span class="mi">500000</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="n">close</span><span class="p">(</span><span class="n">arq</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference download internal" download="" href="../../../_downloads/289190a901ad06922411e4f9aaa0a400/teste1-gpio.c"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">do</span> <span class="pre">código</span> <span class="pre">1</span> <span class="pre">comentado</span></code></a></p>
<p>Para testar o código, o pino 18 (pino do <strong>GPIO</strong> 10) foi conectado a um osciloscópio com o objetivo de medir o período da forma de onda. O resultado dessa medida pode ser visto na figura abaixo, nela podemos ver a amplitude da forma de onda de 1,96 V, frequência de 33,76 kHz e período de 29,62 microssegundos. Para a maioria das aplicações podemos utilizar esse método.</p>
<div class="figure align-center">
<img alt="../../../_images/teste1-gpio.png" src="../../../_images/teste1-gpio.png" />
</div>
</div>
<div class="section" id="controle-do-gpio-via-registradores">
<h2>Controle do GPIO via registradores<a class="headerlink" href="#controle-do-gpio-via-registradores" title="Permalink to this headline">¶</a></h2>
<p>Outra maneira de se controlar o GPIO é escrevendo diretamente nos registradores do sistema. Apesar de o procedimento ser um pouco mais complexo essa, na verdade, é a maneira mais comum e mais recomendada de se realizar esse procedimento oferecendo resultados muito mais rápidos.</p>
<p>Para utilizar este método precisamos, primeiro, definir em quais registradores devemos escrever e o que devemos escrever neles. Essa informação só pode ser encontrada no <a class="reference download internal" download="" href="../../../_downloads/478aee14d85d8b9ee0d031e35242bb99/TRM_DM3730.pdf"><code class="xref download docutils literal notranslate"><span class="pre">Technical</span> <span class="pre">Reference</span> <span class="pre">Manual</span> <span class="pre">(TRM)</span></code></a> do processador DM3730, disponivel no site da <a class="reference external" href="https://www.ti.com/">Texas Instruments</a>.</p>
<p>Como é explicado na seção <strong>25</strong> do TRM do processador DM3730, a partir da página 3477, a interface de controle combina seis bancos de GPIO. Cada modulo de GPIO providencia 32 pinos, totalizando 192 pinos que podem ser utilizados como input e/ou output. Em nosso caso apenas alguns desses 192 pinos estão fisicamente acessíveis, como pode ser visto na figura apresentada abaixo. Cada banco de GPIO possui 26 registradores distribuídos a partir de um endereço de base, sendo que cada um desses registradores possui um comprimento de 32 bits ou 4 bytes.</p>
<div class="figure align-center" id="id2">
<img alt="../../../_images/interface-gpio.png" src="../../../_images/interface-gpio.png" />
<p class="caption"><span class="caption-text">Diagrama da interface de GPIO.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A figura foi retirada do <em>Technical Reference Manual</em> do processador DM3730 e mostra um pouco mais detalhadamente como esses pinos estão distribuídos entre os módulos dos GPIO. A explicação detalhada de cada um desses registradores pode ser encontrada no manual do processador DM3730.</p>
</div>
<p>Neste trabalho apenas dois dos registradores serão comentados de forma a ilustrar o funcionamento desses registradores.</p>
<p>O registrador &quot;<strong>GPIO_OE</strong>&quot; é o registrador que define a direção do pino que está sendo configurado. A abreviação &quot;OE&quot; vem de <em>output enable</em>. Esse registrador possui um offset de endereço igual a &quot;0x034&quot;, ou seja, seu endereço será o endereço de base do modulo do GPIO mais 34 em hexadecimal. Esse registrador possui 32 bits do tipo &quot;Read/White&quot;, ou assim, se o pino correspondente à porta GPIO estiver armazenando o valor <strong>0</strong>, essa porta GPIO estará configurada para operar como output, caso neste pino esteja o valor <strong>1</strong> a porta estará configurada como input.</p>
<p>O registrador &quot;<strong>GPIO_SETDATAOUT</strong>&quot; é o registrador que tem a função de colocar o bit correspondente ao registrador &quot;<strong>GPIO_DATAOUT</strong>&quot; em 1, se tudo estiver configurado corretamente, surgirá no pino físico correspondente o valor de tensão correspondente ao valor 1. Esse registrador possui endereço de offset igual a &quot;0x094&quot;. Assim como o registrador comentado anteriormente este registrador é constituído por 32 bits do tipo &quot;RW&quot;. A leitura de qualquer um dos bits deste registrador retorna o valor do bit correspondente em <strong>GPIO_DATAOUT</strong>&quot;.</p>
<p>Além dos registradores apresentados na seção 25 do <em>Technical Reference Manual</em>, também é necessário configurar um registrador do <em>System Control Module</em> (<strong>SCM</strong>). O SCM é um módulo que permite o Controle através de <em>software</em> de várias funções do dispositivo. Para nossa aplicação, o SCM é o ponto primário de controle da função de GPIO e é nele onde vamos realizar a multiplexação, que determina se o pino irá operar na função de GPIO ou em sua função específica, e definiremos se o GPIO será do tipo <em>pullup</em> ou <em>pulldown</em>, por exemplo.</p>
<p>Os registradores do SCM são divididos em cinco classes. Entretanto, para nossa aplicação iremos utilizar apenas uma, o bloco de registradores de configuração e multiplexação. Esse bloco é um conjunto de registradores de 32 bits, que configura 2 pinos e define, além dos dois parâmetros mencionados anteriormente, a função de <em>wakeup</em>. Aos registradores pertencentes a esse bloco é dado o nome de <em>Configuration Register Functionality</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mais informações sobre o SCM podem ser encontradas na seção 13 do <em>Technical Reference Manual</em>.</p>
</div>
<p>Para encontrarmos qual o endereço de cada registrador deste tipo podemos procurar na tabela 13-4 do TRM. Nessa tabela será dado o endereço físico exato de cada registrador (base+offset). No caso o endereço base é o próprio endereço dos registradores &quot;PADCONFS&quot; da interface do SCM, encontrado na seção 13.6.1 do TRM e o endereço offset de cada registrador deste bloco pode ser encontrado na tabela 13-73 do mesmo documento.</p>
<p>Após a identificação dos registradores podemos iniciar a elaboração de um código para modifica-los. Assim nos deparamos com mais um desafio, sistemas operacionais trabalham com dois conceitos de memória, memória física e memória virtual. Memória física é a memória do hardware, aquela qual sabemos o endereço e pois verificamos no TRM. Entretanto se criarmos um ponteiro que aponta para a memória &quot;0x4800000&quot;, por exemplo, ele não irá apontar para a memória física que possui este endereço pois o sistema operacional mapeia um espaço da memória física diferente para cada programa com os principais objetivos de aumentar a segurança e evitar conflitos de dados entre programas.</p>
<p>Entretanto para ter acesso à memória física do sistema precisamos solicitar ao sistema operacional que mapeie esse espaço de memória para a aplicação. Uma maneira de realizar esse procedimento é através da função &quot;mmap()&quot;.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Detalhes do funcionamento dessa função e seus parâmetro podem ser encontrados em <a class="reference external" href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap(2) — Linux manual page</a>.</p>
</div>
<p>Vamos supor que queremos mapear o espaço de memória físico de &quot;<strong>0x45000000</strong>&quot; até &quot;<strong>0x45001000</strong>&quot; e para isso decidimos usar a função <code class="docutils literal notranslate"><span class="pre">mmap()</span></code>. Portanto, chamamos a função da seguinte maneira, por exemplo, <code class="docutils literal notranslate"><span class="pre">mmap(NULL,0x1000,PROT_WRITE</span> <span class="pre">||</span> <span class="pre">PROT_READ,MAP_SHARED,fd,0x45000000)</span></code>, executando isso a função irá retornar um ponteiro que aponta para um endereço de memória virtual endereçado no endereço de memória física &quot;<strong>0x45000000</strong>&quot;. Em que, para ter acesso à memória física do dispositivo, &quot;<strong>fd</strong>&quot; é o <em>file descriptor</em> direcionado para &quot;/dev/mem&quot;.</p>
<p>Com essas informações, temos tudo o que é necessário para implementar testes acerca deste modo de operação. A seguir temos um código que aplica o método descrito nesta seção para alternar o nível de tensão do pino &quot;186&quot;. Esse código foi implementado para se realizar o mesmo teste da seção &quot;Controle do GPIO via terminal&quot;.</p>
<p>O código abaixo foi obtido no <a class="reference external" href="http://gumstix.8.x6.nabble.com/Direct-register-access-control-of-GPIO-ARM-interface-on-Overo-Water-TOBI-SOLVED-td4965117.html">Fórum de Discussões da Gumstix</a> e foram realizadas pequenas alterações para evitar o excesso de informação e facilitar sua compreensão.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;stdio.h&gt;    // for lprint instruction</span>
<span class="c1">#include &lt;fcntl.h&gt;    // ok for mmap param</span>
<span class="c1">#include &lt;sys/mman.h&gt; // ok for mmap</span>
<span class="c1">#include &lt;unistd.h&gt;</span>

<span class="c1">#define SCM_INTERFACE_BASE 0x48002000</span>
<span class="c1">#define SCM_PADCONFS_BASE 0x48002030</span>
<span class="c1">#define CONTROL_PADCONF_SYS_NIRQ (*(volatile unsigned long *)0x480021E0)</span>
<span class="c1">#define CONTROL_PADCONF_SYS_NIRQ_OFFSET 0x1B0</span>

<span class="c1">#define GPIO6_BASE 0x49058000</span>
<span class="c1">#define GPIO6_SYSCONFIG_OFFSET 0x10</span>
<span class="c1">#define GPIO6_CLEARDATAOUT_OFFSET 0x90</span>
<span class="c1">#define GPIO6_SETDATAOUT_OFFSET 0x94</span>

<span class="c1">#define GPIO6_OE_OFFSET 0x34</span>
<span class="c1">#define GPIO6_CTRL_OFFSET 0x30</span>

<span class="c1">#define MAP_SIZE (volatile unsigned long)4 * 1024</span>
<span class="c1">#define MAP_MASK (volatile unsigned long)(MAP_SIZE - 1)</span>

<span class="c1">#define u32 volatile unsigned long</span>
<span class="n">u32</span> <span class="o">*</span><span class="n">A</span><span class="p">;</span>
<span class="n">u32</span> <span class="o">*</span><span class="n">B</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">i</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">fd</span><span class="p">;</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/dev/mem&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_SYNC</span><span class="p">);</span>

    <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">SCM_INTERFACE_BASE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAP_MASK</span><span class="p">);</span>

    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">A</span> <span class="o">+</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="n">CONTROL_PADCONF_SYS_NIRQ_OFFSET</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="mh">0xfff8ffff</span><span class="p">);</span>
    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">A</span> <span class="o">+</span> <span class="mh">0x30</span> <span class="o">+</span> <span class="n">CONTROL_PADCONF_SYS_NIRQ_OFFSET</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x00040000</span><span class="p">);</span> <span class="o">//</span><span class="nb">set</span> <span class="n">mode</span> <span class="mi">4</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pad</span> <span class="mi">186</span> <span class="n">configuration</span> <span class="n">register</span><span class="p">;</span> <span class="n">enables</span> <span class="n">digital</span> <span class="n">pin</span> <span class="n">use</span>

    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="o">/*****************************************************/</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/dev/mem&quot;</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_SYNC</span><span class="p">);</span>
    <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">volatile</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="n">MAP_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">GPIO6_BASE</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MAP_MASK</span><span class="p">);</span> <span class="o">//</span> <span class="n">COM1</span> <span class="mh">0x4806A000</span>

    <span class="o">//</span><span class="n">gpio_186</span> <span class="n">handling</span>
    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="n">GPIO6_SYSCONFIG_OFFSET</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="mh">0xffffffe0</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="n">GPIO6_SYSCONFIG_OFFSET</span><span class="p">)</span> <span class="o">|=</span> <span class="mh">0x00000014</span><span class="p">;</span> <span class="o">//</span> <span class="n">bit2</span><span class="o">=</span><span class="mi">1</span> <span class="n">enable</span><span class="o">/</span><span class="n">wake</span> <span class="n">up</span><span class="p">,</span> <span class="n">free</span> <span class="n">running</span> <span class="n">clock</span>

    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="n">GPIO6_CTRL_OFFSET</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="mh">0xfffffff8</span><span class="p">;</span> <span class="o">//</span> <span class="n">bit0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bit1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bit2</span><span class="o">=</span><span class="mi">0</span> <span class="n">module</span> <span class="n">enabled</span> <span class="p">,</span> <span class="n">clock</span> <span class="ow">not</span> <span class="n">gated</span><span class="p">,</span> <span class="n">clock</span><span class="o">=</span> <span class="n">interface</span> <span class="n">clock</span> <span class="ow">not</span> <span class="n">divided</span>

    <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="n">GPIO6_OE_OFFSET</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="mh">0xfbffffff</span><span class="p">;</span> <span class="o">//</span><span class="n">bit26</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">gpio_186</span> <span class="n">output</span>

    <span class="o">//</span> <span class="n">generate</span> <span class="n">a</span> <span class="n">pulse</span> <span class="n">stream</span> <span class="n">on</span> <span class="n">gpio_186</span> <span class="n">pin</span> <span class="n">output</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">GPIO6_SETDATAOUT_OFFSET</span><span class="p">))</span> <span class="o">|=</span> <span class="mh">0x04000000</span><span class="p">;</span>
        <span class="o">//</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Saida = 1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="o">//</span> <span class="n">usleep</span><span class="p">(</span><span class="mi">500000</span><span class="p">);</span>
        <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32</span><span class="p">)</span><span class="n">B</span> <span class="o">+</span> <span class="p">(</span><span class="n">GPIO6_CLEARDATAOUT_OFFSET</span><span class="p">))</span> <span class="o">|=</span> <span class="mh">0x04000000</span><span class="p">;</span>
        <span class="o">//</span> <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Saida = 0</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
        <span class="o">//</span> <span class="n">usleep</span><span class="p">(</span><span class="mi">500000</span><span class="p">);</span>

        <span class="o">//</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;j = </span><span class="si">%d</span><span class="s2"> </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference download internal" download="" href="../../../_downloads/08b7c5130cdec9e0a1920e7954049e2b/teste2-gpio.c"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">do</span> <span class="pre">código</span> <span class="pre">2</span> <span class="pre">comentado</span></code></a></p>
<p>O código acima foi testado da mesma maneira que o código apresentado na seção anterior. Já na figura abaixp é possível ver o resultado deste teste. Observe que dessa vez o tempo obtido foi 720,3 nano segundos, ou seja, aproximadamente 42 vezes mais rápido que o resultado do outro método. Além disso, podemos observar que a forma de onda não é mais um sinal retangular exato, a presença de um efeito capacitivo retardando o processo é evidente, portanto, é possível que essa seja a velocidade máxima em que o sinal de um pino pode ser alterado.</p>
<p>Muito dificilmente alguma aplicação envolvendo GPIO não será satisfeita por algum dos métodos aqui apresentados, para finalizar este último tópico é necessário destacar um último problema que ainda não foi resolvido envolvendo escrita em registradores.</p>
<p>O problema ocorre sempre que alteramos qualquer valor de qualquer registrador, o que ocorre é que instantes após a alteração do valor do registrador o valor do registrador retorna ao valor que possuía antes de ser alterado. Como o teste desta seção apresentou frequência muito alta ele não foi interrompido por este efeito, porém o fenômeno ocorre inclusive quando alteramos valores dos registradores por comandos do terminal, como o &quot;devmem2&quot;. Esse problema está exemplificado na figura abaixo.
Muito dificilmente alguma aplicação envolvendo GPIO não será satisfeita por algum dos métodos aqui apresentados. Para finalizar este último tópico é necessário destacar um último problema encontrado envolvendo escrita em registradores.</p>
<p>O problema ocorre sempre que alteramos qualquer valor de qualquer registrador, o que ocorre é que instantes após a alteração do valor do registrador o valor do registrador retorna ao valor que possuía antes de ser alterado. Como o teste desta seção apresentou frequência muito alta ele não foi interrompido por este efeito, porém o fenômeno ocorre inclusive quando alteramos valores dos registradores por comandos do terminal, como o &quot;devmem2&quot;. Esse problema está exemplificado na figura abaixo.</p>
<div class="figure align-center">
<img alt="../../../_images/ErroRegistrador.png" src="../../../_images/ErroRegistrador.png" />
</div>
<p>Na figura executamos o comando <code class="docutils literal notranslate"><span class="pre">devmem2</span></code> para modificar o registrador &quot;<strong>0x49058030</strong>&quot; que é o registrador que controla o clock de todo o bloco do &quot;<strong>GPIO6</strong>&quot;, a modificação deveria realizar uma redução na velocidade do clock dividindo-o por 4, logo após a execução do comando é realizado um procedimento de leitura que garante que tudo foi escrito no registrador como o esperado. No entanto, o mesmo comando é executado instantes depois no modo de leitura e retorna um valor nulo no registrador. No caso o valor existente no registrador antes da modificação era nulo, porém o registrador sempre retorna ao valor anteriormente armazenado. Vale ressaltar que este problema não ocorre para o método de controle do GPIO via terminal, este método opera até que receba uma ordem de parada do usuário.</p>
<p>Procurando resoluções para o problema, encontrou-se no Technical Reference Manual (TRM) do processador DM3730, na seção 25.6.2, página 3511, uma explicação que o <strong>gpio_ctrl</strong> só pode ter seu clock dividido por certos valores pré-cadastrados, sendo eles 2, 4 ou 8.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mh">0x0</span><span class="p">:</span> <span class="n">clock</span> <span class="n">da</span> <span class="n">interface</span>
<span class="mh">0x1</span><span class="p">:</span> <span class="n">clock</span> <span class="n">utliziado</span> <span class="n">é</span> <span class="n">o</span> <span class="n">clock</span> <span class="n">da</span> <span class="n">interface</span> <span class="n">dividido</span> <span class="n">por</span> <span class="mi">2</span>
<span class="mh">0x2</span><span class="p">:</span> <span class="n">clock</span> <span class="n">utilizado</span> <span class="n">é</span> <span class="n">o</span> <span class="n">clock</span> <span class="n">da</span> <span class="n">interface</span> <span class="n">dividido</span> <span class="n">por</span> <span class="mi">4</span>
<span class="mh">0x3</span><span class="p">:</span> <span class="n">clock</span> <span class="n">utilizado</span> <span class="n">é</span> <span class="n">o</span> <span class="n">clock</span> <span class="n">da</span> <span class="n">interface</span> <span class="n">dividido</span> <span class="n">por</span> <span class="mi">8</span>
</pre></div>
</div>
</div></blockquote>
<p>Utilizando o comando <code class="docutils literal notranslate"><span class="pre">devmem2</span></code> para modificar o registrador &quot;<strong>0x49058030</strong>&quot; e realizando o teste para que o clock seja divido por 4 (mesma tentativa do teste não sucedido), nota-se que não é mais retornado o valor anteriormente armazenado (nulo), como podemos observar na figura abaixo.</p>
<div class="figure align-center">
<img alt="../../../_images/GpioCtrl.png" src="../../../_images/GpioCtrl.png" />
</div>
<div class="section" id="referencias">
<h3>Referências<a class="headerlink" href="#referencias" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>PITA, H. C. Desenvolvimento de sistema de comunicação multiplataforma para veículos aéreos de asa fixa. Faculdade de Tecnologia, Universidade de Brasília, 2018.</p></li>
<li><p>TEXAS INSTRUMENTS. AM/DM37x Multimedia Device Technical Reference Manual. 12500 TI Blvd, Dallas, TX 75243, EUA, 2012. Version R. Disponível em: <a class="reference external" href="http://www.ti.com/">ti.com</a>.</p></li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="3.4-Serial.html" class="btn btn-neutral float-right" title="Comunicação Serial" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="3.2-CrossCompilation.html" class="btn btn-neutral float-left" title="Compilação Cruzada" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019, Gabriel Araujo

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>